diff --git a/index.js b/index.js
index 1677b095163d0cd3e0561364a0c7f7fe33de9ff6..988e77121bd05b34ccd9e3231631a0ff5907924f 100644
--- a/index.js
+++ b/index.js
@@ -35,23 +35,23 @@ const onChange = (object, onChange, options = {}) => {
 	// eslint-disable-next-line max-params
 	const validate = (target, property, value, previous, applyData) => !hasOnValidate
 		|| smartClone.isCloning
-		|| options.onValidate(path.concat(cache.getPath(target), property), value, previous, applyData) === true;
+		|| options.onValidate(path.concat(cache.getPath(target), property, Array.isArray(target)), value, previous, applyData) === true;
 
 	const handleChangeOnTarget = (target, property, value, previous) => {
 		if (
 			!ignoreProperty(cache, options, property)
 			&& !(ignoreDetached && cache.isDetached(target, object))
 		) {
-			handleChange(cache.getPath(target), property, value, previous);
+			handleChange(cache.getPath(target), property, value, previous, target);
 		}
 	};
 
 	// eslint-disable-next-line max-params
-	const handleChange = (changePath, property, value, previous, applyData) => {
+	const handleChange = (changePath, property, value, previous, applyData, target) => {
 		if (smartClone.isCloning && smartClone.isPartOfClone(changePath)) {
 			smartClone.update(changePath, property, previous);
 		} else {
-			onChange(path.concat(changePath, property), value, previous, applyData);
+			onChange(path.concat(changePath, property, Array.isArray(target)), value, previous, applyData);
 		}
 	};
 
@@ -83,7 +83,7 @@ const onChange = (object, onChange, options = {}) => {
 		then we are on a circular case, where the child is pointing to their parent.
 		In this case we return the proxy object with the shortest path.
   		*/
-		const childPath = path.concat(basePath, property);
+		const childPath = path.concat(basePath, property, Array.isArray(target));
 		const existingPath = cache.getPath(value);
 
 		if (existingPath && isSameObjectTree(childPath, existingPath)) {
@@ -256,7 +256,7 @@ const onChange = (object, onChange, options = {}) => {
 						: '';
 
 					if (validate(path.get(object, changePath), property, thisProxyTarget, previous, applyData)) {
-						handleChange(changePath, property, thisProxyTarget, previous, applyData);
+						handleChange(changePath, property, thisProxyTarget, previous, applyData, target);
 					} else {
 						smartClone.undo(thisProxyTarget);
 					}
diff --git a/lib/path.js b/lib/path.js
index abe7c4b4c4e92dc8043303b155a4dc316c181d96..fb1383696e381117d1fe4b01f8388b3c48527dbb 100644
--- a/lib/path.js
+++ b/lib/path.js
@@ -14,12 +14,12 @@ const path = {
 
 		return path.slice(subPath.length + 1);
 	},
-	concat(path, key) {
+	concat(path, key, targetIsArray) {
 		if (isArray(path)) {
 			path = [...path];
 
 			if (key) {
-				path.push(key);
+				path.push(targetIsArray ? +key : key);
 			}
 
 			return path;
